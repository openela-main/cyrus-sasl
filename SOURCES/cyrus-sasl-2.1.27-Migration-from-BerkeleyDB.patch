diff -up cyrus-sasl-2.1.27/configure.ac.frombdb cyrus-sasl-2.1.27/configure.ac
--- cyrus-sasl-2.1.27/configure.ac.frombdb	2021-06-04 13:02:07.790112263 +0200
+++ cyrus-sasl-2.1.27/configure.ac	2021-06-04 13:02:07.798112327 +0200
@@ -1091,6 +1091,9 @@ AC_SUBST(SASL_STATIC_SRCS)
 AC_SUBST(SASL_STATIC_OBJS)
 AC_SUBST(SASL_STATIC_LIBS)
 
+CYRUS_BERKELEY_DB_STATIC_LIB()
+AC_SUBST(BDB_STATIC_LIBADD)
+
 AC_ARG_WITH(plugindir, [  --with-plugindir=DIR    set the directory where plugins will
                           be found [[LIBDIR/sasl2]] ],
   plugindir=$withval,
diff -up cyrus-sasl-2.1.27/m4/berkdb.m4.frombdb cyrus-sasl-2.1.27/m4/berkdb.m4
--- cyrus-sasl-2.1.27/m4/berkdb.m4.frombdb	2016-01-29 18:35:35.000000000 +0100
+++ cyrus-sasl-2.1.27/m4/berkdb.m4	2021-06-04 13:02:07.798112327 +0200
@@ -286,3 +286,10 @@ AC_DEFUN([CYRUS_BERKELEY_DB_CHK],
 
 	CPPFLAGS=$cmu_save_CPPFLAGS
 ])
+
+AC_DEFUN([CYRUS_BERKELEY_DB_STATIC_LIB],
+[
+BDB_STATIC_LIBADD="/dev/null -lpthread"
+AC_CHECK_FILE([/usr/lib64/libdb-5.3.a],[BDB_STATIC_LIBADD="/usr/lib64/libdb-5.3.a -lpthread "],[])
+AC_CHECK_FILE([/usr/lib/libdb-5.3.a],[BDB_STATIC_LIBADD="/usr/lib/libdb-5.3.a -lpthread"],[])
+])
diff -up cyrus-sasl-2.1.27/m4/sasldb.m4.frombdb cyrus-sasl-2.1.27/m4/sasldb.m4
--- cyrus-sasl-2.1.27/m4/sasldb.m4.frombdb	2017-07-13 20:45:19.000000000 +0200
+++ cyrus-sasl-2.1.27/m4/sasldb.m4	2021-06-04 13:02:07.798112327 +0200
@@ -111,7 +111,7 @@ AC_MSG_RESULT($dblib)
 SASL_DB_BACKEND="db_${dblib}.lo"
 SASL_DB_BACKEND_STATIC="db_${dblib}.o allockey.o"
 SASL_DB_BACKEND_STATIC_SRCS="\$(top_srcdir)/sasldb/db_${dblib}.c \$(top_srcdir)/sasldb/allockey.c"
-SASL_DB_UTILS="saslpasswd2 sasldblistusers2"
+SASL_DB_UTILS="cyrusbdb2current saslpasswd2 sasldblistusers2"
 SASL_DB_MANS="saslpasswd2.8 sasldblistusers2.8"
 
 case "$dblib" in
diff -up cyrus-sasl-2.1.27/sasldb/db_gdbm.c.frombdb cyrus-sasl-2.1.27/sasldb/db_gdbm.c
--- cyrus-sasl-2.1.27/sasldb/db_gdbm.c.frombdb	2017-07-13 14:34:03.000000000 +0200
+++ cyrus-sasl-2.1.27/sasldb/db_gdbm.c	2021-06-04 13:04:24.098206887 +0200
@@ -67,6 +67,7 @@ int _sasldb_getdata(const sasl_utils_t *
   void *cntxt;
   sasl_getopt_t *getopt;
   const char *path = SASL_DB_PATH;
+  int fetch_errno = 0;
 
   if (!utils) return SASL_BADPARAM;
   if (!authid || !propName || !realm || !out || !max_out) {
@@ -99,6 +100,9 @@ int _sasldb_getdata(const sasl_utils_t *
   }
   db = gdbm_open((char *)path, 0, GDBM_READER, S_IRUSR | S_IWUSR, NULL);
   if (! db) {
+      utils->log(conn, SASL_LOG_ERR,
+		 "SASL error opening password file. "
+		 "Have you performed the migration from db2 using cyrusbdb2current?\n");
       utils->seterror(cntxt, 0, "Could not open %s: gdbm_errno=%d",
 		      path, gdbm_errno);
       result = SASL_FAIL;
@@ -107,9 +111,10 @@ int _sasldb_getdata(const sasl_utils_t *
   gkey.dptr = key;
   gkey.dsize = key_len;
   gvalue = gdbm_fetch(db, gkey);
+  fetch_errno = gdbm_errno;
   gdbm_close(db);
   if (! gvalue.dptr) {
-      if (gdbm_errno == GDBM_ITEM_NOT_FOUND) {
+      if (fetch_errno == GDBM_ITEM_NOT_FOUND) {
           utils->seterror(conn, SASL_NOLOG,
 			  "user: %s@%s property: %s not found in %s",
 			  authid, realm, propName, path);
@@ -186,7 +191,8 @@ int _sasldb_putdata(const sasl_utils_t *
   if (! db) {
       utils->log(conn, SASL_LOG_ERR,
 		 "SASL error opening password file. "
-		 "Do you have write permissions?\n");
+		 "Do you have write permissions?\n"
+		 "Have you performed the migration from db2 using cyrusbdb2current?\n");
       utils->seterror(conn, 0, "Could not open %s for write: gdbm_errno=%d",
                      path, gdbm_errno);
       result = SASL_FAIL;
@@ -298,6 +304,9 @@ sasldb_handle _sasldb_getkeyhandle(const
     db = gdbm_open((char *)path, 0, GDBM_READER, S_IRUSR | S_IWUSR, NULL);
 
     if(!db) {
+        utils->log(conn, SASL_LOG_ERR,
+		 "SASL error opening password file. "
+		 "Have you performed the migration from db2 using cyrusbdb2current?\n");
         utils->seterror(conn, 0, "Could not open %s: gdbm_errno=%d",
 			 path, gdbm_errno);
 	return NULL;
diff -up cyrus-sasl-2.1.27/utils/cyrusbdb2current.8.frombdb cyrus-sasl-2.1.27/utils/cyrusbdb2current.8
--- cyrus-sasl-2.1.27/utils/cyrusbdb2current.8.frombdb	2021-06-04 13:02:07.798112327 +0200
+++ cyrus-sasl-2.1.27/utils/cyrusbdb2current.8	2021-06-04 13:02:07.798112327 +0200
@@ -0,0 +1,159 @@
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+.    ds C`
+.    ds C'
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is >0, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{\
+.    if \nF \{\
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
+..
+.        if !\nF==2 \{\
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
+.\}
+.rr rF
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "CYRUSBDB2CURRENT 1"
+.TH CYRUSBDB2CURRENT 1 "2021-04-28" "perl v5.30.3" "User Contributed Perl Documentation"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+cyrusbdb2current \- command\-line utility converting the SASLDB database from
+BerkeleyDB to the database format currently used bys sasldb.
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+cyrusbdb2current <sasldb_old_path> <sasldb_new_path>
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+\&\fBcyrusbdb2current\fR converts the current sasldb database from BerkeleyDB format to the
+currently used database format. It is \fB\s-1STRONGLY RECOMMENDED\s0\fR to make a backup
+of the current database before the conversion.
+.PP
+We expect that the old path is \fB/etc/sasldb2\fR and the new one is
+\&\fB/etc/sasl2/sasldb2\fR
+.SH "SEE ALSO"
+.IX Header "SEE ALSO"
+\&\fBsaslpasswd2\fR\|(8)
+.PP
+rfc4422 \- Simple Authentication and Security Layer (\s-1SASL\s0)
diff -up cyrus-sasl-2.1.27/utils/cyrusbdb2current.c.frombdb cyrus-sasl-2.1.27/utils/cyrusbdb2current.c
--- cyrus-sasl-2.1.27/utils/cyrusbdb2current.c.frombdb	2021-06-04 13:02:07.798112327 +0200
+++ cyrus-sasl-2.1.27/utils/cyrusbdb2current.c	2021-06-04 13:02:07.798112327 +0200
@@ -0,0 +1,282 @@
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <sasl.h>
+#include <saslplug.h>
+#include "../sasldb/sasldb.h"
+
+/* Cheating to make the utils work out right */
+extern const sasl_utils_t *sasl_global_utils;
+sasl_conn_t *globalconn;
+
+typedef void *listcb_t(const char *, const char *, const char *,
+		       const char *, unsigned);
+
+void listusers_cb(const char *authid, const char *realm,
+		  const char *propName, const char *secret,
+		  unsigned seclen)
+{
+    if (!authid || !propName || !realm) {
+	fprintf(stderr,"userlist callback has bad param");
+	return;
+    }
+
+    /* the entries that just say the mechanism exists */
+    if (strlen(authid)==0) return;
+
+    printf("Converting: %s@%s (%s)...",authid,realm,propName);
+
+    _sasldb_putdata(sasl_global_utils, globalconn,
+		    authid, realm, propName,
+		    secret, seclen);
+
+    printf("ok\n");
+}
+
+/*
+ * List all users in database
+ */
+
+#include <db.h>
+
+#define DB_VERSION_FULL ((DB_VERSION_MAJOR << 24) | (DB_VERSION_MINOR << 16) | DB_VERSION_PATCH)
+/*
+ * Open the database
+ *
+ */
+static int berkeleydb_open(const char *path,DB **mbdb)
+{
+    int ret;
+
+#if DB_VERSION_FULL < 0x03000000
+    ret = db_open(path, DB_HASH, DB_CREATE, 0664, NULL, NULL, mbdb);
+#else /* DB_VERSION_FULL < 0x03000000 */
+    ret = db_create(mbdb, NULL, 0);
+    if (ret == 0 && *mbdb != NULL)
+    {
+#if DB_VERSION_FULL >= 0x04010000
+	ret = (*mbdb)->open(*mbdb, NULL, path, NULL, DB_HASH, DB_CREATE, 0664);
+#else
+	ret = (*mbdb)->open(*mbdb, path, NULL, DB_HASH, DB_CREATE, 0664);
+#endif
+	if (ret != 0)
+	{
+	    (void) (*mbdb)->close(*mbdb, 0);
+	    *mbdb = NULL;
+	}
+    }
+#endif /* DB_VERSION_FULL < 0x03000000 */
+
+    if (ret != 0) {
+	fprintf(stderr,"Error opening password file %s\n", path);
+	return SASL_FAIL;
+    }
+
+    return SASL_OK;
+}
+
+/*
+ * Close the database
+ *
+ */
+
+static void berkeleydb_close(DB *mbdb)
+{
+    int ret;
+    
+    ret = mbdb->close(mbdb, 0);
+    if (ret!=0) {
+	fprintf(stderr,"error closing sasldb: %s",
+		db_strerror(ret));
+    }
+}
+
+int listusers(const char *path, listcb_t *cb)
+{
+    int result;
+    DB *mbdb = NULL;
+    DBC *cursor;
+    DBT key, data;
+
+    /* open the db */
+    result=berkeleydb_open(path, &mbdb);
+    if (result!=SASL_OK) goto cleanup;
+
+    /* make cursor */
+#if DB_VERSION_FULL < 0x03060000
+    result = mbdb->cursor(mbdb, NULL,&cursor); 
+#else
+    result = mbdb->cursor(mbdb, NULL,&cursor, 0); 
+#endif /* DB_VERSION_FULL < 0x03060000 */
+
+    if (result!=0) {
+	fprintf(stderr,"Making cursor failure: %s\n",db_strerror(result));
+      result = SASL_FAIL;
+      goto cleanup;
+    }
+
+    memset(&key,0, sizeof(key));
+    memset(&data,0,sizeof(data));
+
+    /* loop thru */
+    result = cursor->c_get(cursor, &key, &data,
+			   DB_FIRST);
+
+    while (result != DB_NOTFOUND)
+    {
+	char *authid;
+	char *realm;
+	char *tmp;
+	unsigned int len;
+	char prop[1024];
+	int numnulls = 0;
+	unsigned int lup;
+
+	/* make sure there are exactly 2 null's */
+	for (lup=0;lup<key.size;lup++)
+	    if (((char *)key.data)[lup]=='\0')
+		numnulls++;
+
+	if (numnulls != 2) {
+	    fprintf(stderr,"warning: probable database corruption\n");
+	    result = cursor->c_get(cursor, &key, &data, DB_NEXT);
+	    continue;
+	}
+
+	authid = key.data;
+	realm  = authid + strlen(authid)+1;
+	tmp    = realm + strlen(realm)+1;
+	len = key.size - (tmp - authid);
+
+	/* make sure we have enough space of prop */
+	if (len >=sizeof(prop)) {
+	    fprintf(stderr,"warning: absurdly long prop name\n");
+	    result = cursor->c_get(cursor, &key, &data, DB_NEXT);
+	    continue;
+	}
+
+	memcpy(prop, tmp, key.size - (tmp - ((char *)key.data)));
+	prop[key.size - (tmp - ((char *)key.data))] = '\0';
+
+	if (*authid) {
+	    /* don't check return values */
+	    cb(authid,realm,prop,data.data,data.size);
+	}
+
+	result = cursor->c_get(cursor, &key, &data, DB_NEXT);
+    }
+
+    if (result != DB_NOTFOUND) {
+	fprintf(stderr,"failure: %s\n",db_strerror(result));
+	result = SASL_FAIL;
+	goto cleanup;
+    }
+
+    result = cursor->c_close(cursor);
+    if (result != 0) {
+        result = SASL_FAIL;
+        goto cleanup;
+    }
+
+    result = SASL_OK;
+
+ cleanup:
+
+    if (mbdb != NULL) berkeleydb_close(mbdb);
+    return result;
+}
+
+
+char *db = NULL, *db_new=NULL;
+
+int good_getopt(void *context __attribute__((unused)), 
+		const char *plugin_name __attribute__((unused)), 
+		const char *option,
+		const char **result,
+		unsigned *len)
+{
+    if (db_new && !strcmp(option, "sasldb_path")) {
+	*result = db_new;
+	if (len)
+	    *len = strlen(db_new);
+	return SASL_OK;
+    }
+
+    return SASL_FAIL;
+}
+
+static struct sasl_callback goodsasl_cb[] = {
+    { SASL_CB_GETOPT, (int (*)(void))&good_getopt, NULL },
+    { SASL_CB_LIST_END, NULL, NULL }
+};
+
+int main(int argc, char **argv)
+{
+    int result;
+    FILE *f;
+
+    if (argc != 3) {
+	fprintf(stderr, "Usage: cyrusbdb2current old_sasldb new_sasldb\n");
+	fprintf(stderr, "old_sasldb is presumably /etc/sasldb2\n");
+       	fprintf(stderr, "new_sasldb is presumably /etc/sasl2/sasldb2\n");
+	return 1;
+    }
+
+    db = argv[1];
+    db_new = argv[2];
+
+    if (strcmp(db, db_new) == 0) {
+	fprintf(stderr, "Old and new files should be different\n");
+	return 1;
+    }
+
+
+    f = fopen(db_new, "rb");
+    if (f != NULL) {
+	fprintf(stderr, "The specified target file %s already exists\n", db_new);
+	fclose(f);
+	return 1;
+    }
+
+    result = sasl_server_init(goodsasl_cb, "dbconverter");
+    if (result != SASL_OK) {
+	fprintf(stderr, "couldn't init saslv2\n");
+	return 1;
+    }
+
+    result = sasl_server_new("sasldb",
+			     "localhost",
+			     NULL,
+			     NULL,
+			     NULL,
+			     NULL,
+			     0,
+			     &globalconn);
+    if (result != SASL_OK) {
+	fprintf(stderr, "couldn't create globalconn\n");
+	return 1;
+    }
+
+    if(_sasl_check_db(sasl_global_utils,globalconn) != SASL_OK) {
+	fprintf(stderr, "target DB %s is not OK\n", db_new);
+	return 1;
+    }
+
+    printf("\nThis program will take the sasldb file specified on the\n"
+           "command line and convert it to a new sasldb specified\n"
+           "on the command line. It is STRONGLY RECOMMENDED that you\n"
+           "backup sasldb before allowing this program to run\n\n"
+	   "We are going to convert %s and our output will be in %s\n\n"
+           "Press return to continue\n", db, db_new);
+
+    getchar();
+
+    listusers(db, (listcb_t *) &listusers_cb);
+
+    sasl_dispose(&globalconn);
+    sasl_done();
+
+    exit(0);
+}
diff -up cyrus-sasl-2.1.27/utils/Makefile.am.frombdb cyrus-sasl-2.1.27/utils/Makefile.am
--- cyrus-sasl-2.1.27/utils/Makefile.am.frombdb	2018-10-05 16:40:16.000000000 +0200
+++ cyrus-sasl-2.1.27/utils/Makefile.am	2021-06-04 13:02:07.798112327 +0200
@@ -46,14 +46,14 @@ all_sasl_libs = ../lib/libsasl2.la $(SAS
 all_sasl_static_libs = ../lib/.libs/libsasl2.a $(SASL_DB_LIB) $(LIB_SOCKET) $(GSSAPIBASE_LIBS) $(GSSAPI_LIBS) $(SASL_KRB_LIB) $(LIB_DES) $(PLAIN_LIBS) $(SRP_LIBS) $(LIB_MYSQL) $(LIB_PGSQL) $(LIB_SQLITE)
 
 sbin_PROGRAMS = @SASL_DB_UTILS@ @SMTPTEST_PROGRAM@ pluginviewer
-EXTRA_PROGRAMS = saslpasswd2 sasldblistusers2 testsuite testsuitestatic smtptest pluginviewer
+EXTRA_PROGRAMS = saslpasswd2 sasldblistusers2 testsuite testsuitestatic smtptest pluginviewer cyrusbdb2current
 
 noinst_PROGRAMS = dbconverter-2
 
 if NO_SASL_DB_MANS
 man_MANS = 
 else
-man_MANS = saslpasswd2.8 sasldblistusers2.8 pluginviewer.8
+man_MANS = saslpasswd2.8 sasldblistusers2.8 pluginviewer.8 cyrusbdb2current.8
 endif
 
 saslpasswd2_LDADD = ../sasldb/libsasldb.la $(all_sasl_libs)
@@ -63,6 +63,7 @@ sasldblistusers2_SOURCES = sasldblistuse
 dbconverter_2_LDADD = ../sasldb/libsasldb.la $(all_sasl_libs)
 pluginviewer_LDADD = $(all_sasl_libs)
 pluginviewer_SOURCES = pluginviewer.c
+cyrusbdb2current_LDADD = ../sasldb/libsasldb.la @BDB_STATIC_LIBADD@ $(all_sasl_libs)
 
 testsuite_LDADD = $(all_sasl_libs) @DMALLOC_LIBS@
 
